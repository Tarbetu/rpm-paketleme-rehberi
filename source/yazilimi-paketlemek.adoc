[[yazilimi-paketlemek]]
= Yazılımı Paketlemek

Bu kaynakça, Red Hat bağlantılı dağıtımlar için paketlemeyi öncelikle ele alır. Bu dağıtımlar aşağıda listelenmiştir:

*   https://getfedora.org/[Fedora]
*   https://www.centos.org/[CentOS]
*   https://www.redhat.com/en/technologies/linux-platforms[Red Hat Enterprise Linux] (https://www.redhat.com/en/technologies/linux-platforms[RHEL])

Bu dağıtımlar, http://rpm.org/[RPM] paketleme usulünü kullanır. 

Yine de, bu yazı çoğunlukla bahsi geçen sistemleri hedef alsa bu rehber çoğu https://en.wikipedia.org/wiki/List_of_Linux_distributions#RPM-based[RPM temelli] dağıtıma uygulanabilir. Ancak dağıtımların kendisine özgü rehberleri, makroları ve önhazırlık maddeleri incelenmelidir. 

Bu rehber, okuyucunun Linux veya başka bir işletim sistemiyle ilgili herhangi bir altyapısı olmadığını varsayar. 

Not: Eğer yazılım paketleme ve Linux dağıtımları hakkında hiçbir fikriniz yoksa öncelikle https://tr.wikipedia.org/wiki/Linux[Linux] ve https://tr.wikipedia.org/wiki/Paket_yönetim_sistemi[Paket Yöneticileri] hakkında bir ön araştırma yapmayı düşünebilirsiniz.  

[[rpm-paketleri]]
== RPM Paketleri

Bu bölüm, RPM hakkında basit bilgileri içerir. Eğer daha ileri düzey bilgiler görmek isterseniz xref:gelismis-konular[] başlığını inceleyebilirsiniz. 

[[rpm-nedir]]
=== RPM Nedir?

Bir RPM paketi, basitçe sistem tarafından gereken bilgileri ve dosyaları içeren bir dosyadır. Detaya inersek, bir RPM paketi https://en.wikipedia.org/wiki/Cpio[cpio] ismi verilen bir arşiv türüdür. ``RPM`` paket yöneticisi üstveri aracılığıyla bağımlılıkları saptar, nereye kurulması gerektiğini anlar ve diğer bilgileri ele alır. 

İki tip RPM paketleri vardır:

* Kaynak RPM (SRPM, Source RPM'in kısaltmasıdır)
* İkili RPM

Kaynak ve ikili RPMler aynı dosya biçimini ve araçlarını kullanırlar ancak farklı içeriklere ve amaçlara sahiptirler. Bir SRPM, kaynak kodunu ve isteğe bağlı olarak yamalarını ve bir SPEC dosyasını içerir ki SPEC, kaynak kodunun nasıl ikili RPM'e çevirilmesi gerektiğini içerir. Bir ikili RPM ise kaynak kodunun ve yamalarının derlenmiş hâlidir.

[[rpm-paketleme-araclari]]
=== RPM Paketleme Araçları

xref:on-kosullar[]'da belirtilmiş ``rpmdevtools`` paketi pek RPM paketlemek için pek çok aracı içerir. Bu araçları listemek için şu komutu çalıştırın:

[source,bash]
----
$ rpm -ql rpmdevtools | grep bin

----

Bu araçlar hakkında bilgi edinmek için o araçların kullanım talimatlarını veya yardım yazılarını inceleyebilirsiniz. 

[[rpm-paketlemesi-icin-calisma-alani]]
=== RPM Paketlemesi İçin Çalışma Alanı

RPM için çalışma alanı oluşturacak bir dizin hazırlamak istiyorsanız ``rpmdev-setuptree`` aracını kullanın.

[source,bash]
----
$ rpmdev-setuptree

$ tree ~/rpmbuild/
/home/user/rpmbuild/
|-- BUILD
|-- RPMS
|-- SOURCES
|-- SPECS
`-- SRPMS

5 directories, 0 files

----

Oluşturulan bu dizinler şu amaçlara hizmet eder:

[cols="20%,80%"]
|====
| Dizin     | Amaç
| BUILD     | Bir paket inşa edildiği zaman gereken ``%buildroot`` dizinleri burada oluşturulur. Bu dizinleri incelemek, hata kayıtlarının yetersiz kaldığı zamanlar nerede hata çıktığını anlamaya yardımcı olur.
| RPMS      | İkili RPMler mimarilere göre ayrılmış altdizinlere göre burada oluşturulur. Bu dizinler ``x86_64`` veya ``noarch`` olabilir. 
| SOURCES   | Burada paketçinin sıkıştırılmış kaynak kodu arşivleri ve yamaları bulunur. ``rpmbuild`` komutu burayı arar.
| SPECS     | Paketçi SPEC dosyalarını buraya yerleştirir. 
| SRPMS     | Eğer ``rpmbuild`` paketi ikili RPM üretmek yerine SRPM inşa etmek için kullanılırsa, SRPMler burada oluşturulur. 
|====

[[spec-dosyasi-nedir]]
=== Bir Spec Dosyası Nedir?

Eğer RPM paketlerini yemeğe benzetirsek SPEC dosyasını, ``rpmbuild`` aracının RPM pişirmek için baz aldığı bir yemek tarifi olarak düşünebiliriz. SPEC dosyası, inşa ortamına neler yapması gerektiğini çeşitli parçalar hâlinde bildirir. Bu parçalar, __Önsöz__ (__Preamble__) ve __Gövde__ (__Body__) olarak ikiye ayrılabilir. __Gövde__ kısmı, talimatların esas parçasını içerir. 

[[onsoz-maddeleri]]
==== Önsöz Maddeleri 

Aşağıdaki tablo RPM Spec dosyasının Önsöz kısmında kullanılan maddeleri listeler. 

[cols="30%,70%"]
|====
| SPEC Yönergeleri  | Açıklama
| ``Name``          | Paketin esas adı, SPEC dosyasının adıyla eşleşmelidir. 
| ``Version``       | Yazılımın sürüm sayısını içerir. 
| ``Release``       | Bu sürümün kaç defa yayınlandığını içerir. Normal olarak, ilk yayının değeri 1%{?dist} olarak belirlenir ve her yeni yayında sayı arttırılır. Yeni ``Version`` (sürüm) yayınlandığında tekrar 1 olur. 
| ``Summary``       | Paketin kısa ve tek satırlık özetini içerir. 
| ``License``       | Paketlenen yazılımın lisansını belirtir. 
ifdef::community[]
https://getfedora.org/[Fedora] gibi topluluk dağıtımlarda dağıtılan paketler, dağıtımın lisanslama rehberlerinde bahsedildiği şekilde özgür yazılım lisansına uygun olmak zorundadır. 
endif::community[]
| ``URL``           | Dağıtım hakkında daha fazla bilginin alınabileceği tam adrestir. Çoğu zaman bu adres aynı zamanda yazılımın ana sayfasıdır. 
| ``Source0``       | Yazılımın kaynak kodunu barındıran internet adresi veyahut dosya konumudur. Her an erişilebilecek ve güvenilir bir yere atıfta bulunması tavsiye edilir. Güvenilir yerden kasıt, paketçinin yerel depolaması yerine yazılımın İnternet sayfasıdır. Eğer gereklyise daha fazla SourceX yönergesi eklenebilir. (X yerine sayı gelir ve sayılar birer arttırılır. Örnek: Source1, Source2, Source3 gibi)
| ``Patch0``        | Eğer gerekliyse kaynak koduna uygulanacak olan ilk yama burada belirtilir. İhtiyaç duyulması hâlinde, SourceX gibi fazladan PatchX eklenebilir. (Patch1, Patch2, Patch3 gibi)
| ``BuildArch``     | Eğer yazılım bir mimariye yönelik değilse, mesela tamamen yorumlanan bir dille yazılmışsa, bu yönerge ``BuildArch: noarch`` olarak ayarlanır. Eğer bu yönerge belirtilmezse, makinenin üzerinde çalıştığı mimariye ayarlanır. Örnek: ``x86_64``
| ``BuildRequires`` | Derlenen bir dilde inşa edilmiş paketleri inşa etmek için gereken programların virgülle veya boşluklarla ayrıldığı listelerdir. ``BuildRequires`` yönergesi, aynı satırda kalındığı müddetçe, birden fazla yazılım belirtebilir. 
| ``Requires`` | Yazılımların kurulması için gereken bağımlılıkların virgülle veya  boşluklarlarla belirtildiği bir listedir. Tıpkı ``BuildRequires`` gibi, ``Requires`` yönergesi de satırına sadık kalınarak birden fazla yazılımı belirtebilir. 
| ``ExcludeArch``   | Eğer yazılım belirli bir işlemci mimarisinde çalışmayacaksa, o mimariyi burada dışlayabilirsiniz. 
|====

``Name``, ``Version`` ve ``Release`` yönergeleri RPM paketinin dosya ismini oluşturur. RPM Paket geliştiricileri ve sistem yöneticileri bu üç direktifi **N-V-R** ya da **NVR** olarak isimlendirir. Çünkü RPM paketleri ``NAME-VERSION-RELEASE`` biçimiyle isimlendirilir. 

``NAME-VERSION-RELEASE`` biçiminin örneklerini, ``rpm`` komutu aracılığıyla paketleri sorgulayarak bulabilirsiniz: 

[source,bash]
----
$ rpm -q python
python-2.7.5-34.el7.x86_64

----
``python``, paket ismini gösteren ``Name`` direktifine, ``2.7.5``, ``Version`` direktifine ve ``34.el7`` ise ``Release`` direktifine atıfta bulunur. Son işaretçi olan ``x86_64`` ise mimariyi gösterir. **NVR** üçlüsünün aksine, mimari paketçinin insiyatifinde değildir fakat ``rpmbuild`` tarafından belirlenmiştir. Bu duruma bir istisna, paketin mimariden bağımsız olduğunu belirten ``noarch`` ibaresidir.

[[govde-maddeleri]]
==== Gövde Maddeleri

Aşağıdaki tablo, bir RPM SPEC dosyasının Gövde kısmındaki maddeleri listeler:

[cols="20%,80%"]
|====
| SPEC Yönergesi   | Açıklama
| ``%description`` | RPM'e paketlenen yazılım için tam bir açıklamayı içerir. Bu açıklama birden fazla satırı, hatta paragrafları içerebilir. 
| ``%prep``        | Yazılımı kuruluma hazırlayan komutları içeren komut ya da komutları içerir. Örneğin, bu ``Source0`` içerisinde bulunan arşiv dosyasını çıkartmak olabilir. Bu yönerge, bir kabuk betiğini içerebilir. 
| ``%build``       | Yazılımı makine koduna veyahut bayt koduna derlemek için kullanılan komut veyahut komutları içerir. 
| ``%install``     | İstenen inşa yapılarını ``%builddir`` (Derleme konumunu içerir) içerisinden ``%buildroot``a taşıyan (paketlenecek dizin yapısını barındıran dizin) komut veya komutları içerir. Bu işlem çoğu zaman dosyaları ``~/rpmbuild/BUILD`` konumundan ``~/rpmbuild/BUILDROOT``'a taşımak anlamına gelir. Bu komutlar yalnızca paketi inşa ederken çalıştırılır, son kullanıcı paketi kurarken değil. Daha fazla bilgi için xref:spec-dosyalari-ile-calismak[] kısmını inceleyin.
| ``%check``       | Yazılımı denetlemek için kullanılan komut ya da komutları içerir. Bu kısım çoğu zaman birim testlerinden oluşur. 
| ``%files``       | Bu kısımda listenen dosyalar paketi kuran son kullanıcının sistemine yerleştirilir. 
| ``%changelog``   | Paketin ``Version`` ve ``Release`` numaraları değiştiğinde ne değiştiğini bildirmek için kullanılır. 
|====

[[ileri-duzey-maddeler]]
==== İleri Düzey Maddeler

Aynı zamanda, SPEC dosyaları ileri düzey maddeleri de içerebilir. Örneğin, bir SPEC dosyası __betikçi__ ve __tetikleyici__leri içerebilir. Bu yöngergeler, son kullanıcı kendi sistemine kurarken farklı noktaları etkiler. (Paket inşa sürecini etkilemez) 

Daha fazla bilgi için xref:tetikleyiciler-ve-betikciler[] kısmını okuyabilirsiniz. 

[[buildroot]]
=== BuildRoot

Ç.N: BuildRoot, Build (İnşa/Derleme) ve Root (Kök) kelimelerinden ortaya çıkan, motamot çevirisi ``DerlemeKökü`` olan bir kelime. Bu kelime daha önce karşılaştığımız ``Tarball`` ve şimdi denk geleceğimiz ``chroot`` gibi, literatür içerisinde yer edindiğinden çevirmek istemedim. Bu yüzden, yazı boyunca ``BuildRoot`` kelimesini kullanmaya devam edeceğim. Eğer bu kelimeye karşılık gelen iyi bir karşılık bulursanız bana bildirebilirsiniz. 

RPM paketleme bağlamında, "buildroot" bir https://en.wikipedia.org/wiki/Chroot[Chroot] ortamıdır. Bu ortam dosya sistemi içerisindeki derleme yapıları bu dizine yerleştirilir. Bu dizin, paketi kuracak tarafın sisteminin kök dizinini temsil eder. Bu yerleştirme düzeninin son kullanıcının Dosya Sistemi Hiyerarşisi standartlarına uygun olması şiddetle tavsiye edilir. 

"Buildroot" içerisine eklenen dosyalar bir https://en.wikipedia.org/wiki/Cpio[cpio] arşivine dönüştürülür ki bu RPM'in temel parçasıdır. RPM paketi, son kullanıcının sistemine kurulduğu zaman bu dizindeki dosyalar hiyerarşiye uygun olarak kök dizin içerisine çıkartılır. 

[NOTE]
====
// Geçmişte, `%buildroot` makrosunun `%~/rpmmacros` içerisine tanımlanması veya SPEC dosyasında `BuildRoot` belirtilmesi tavsiye edilirdi. RedHat Enterprise Linux 6'dan itibaren `rpmbuild` yazılımı kendi varsayılanlarını benimsedi. Bu varsayılanları yeniden tanımlamak belli başlı sıkıntılar doğurabileceğinden, Red Hat bu makroyu değiştirmenizi tavsiye etmez. `%{buildroot}` makrosunu `rpmbuild` dizinindeki varsayılanıyla kullanabilirsiniz.
====

[[rpm-makrolari]]
=== RPM Makroları

Bir http://rpm.org/user_doc/macros.html[rpm makro]su, belirli gömülü işlevleri yerine getirmek için kullanılan ve koşula göre değişen değerleri tutan kısa bir yazıdır. Bu demek oluyor ki, bilmek zorunda olmadığınız şeyleri RPM'e havale edebilirsiniz.

Mesela şöyle bir durum düşünelim; SPEC dosyasını hazırlarken yazılım sürümünü tekrar tekrar yazmak istemediğiniz zaman makrolar size yardımcı olur. Daha önce tanımladığınız __Version__ yönergesini, sonraları ``%{version}`` makrosunu kullanarak çağırabilirsiniz. Her ``%{version}`` makrosu, otomatik olarak __Version__ yöngersiyle yer değiştirecektir.

[NOTE]
====
Eğer bir makronun ne iş yaptığını çıkartamazsanız şu şekilde ne iş yaptığını çıkartabilirsiniz:

[source,bash]
----
$ rpm --eval %{_MAKRO}

----

Örneğin:

[source,bash]
----
$ rpm --eval %{_bindir}
/usr/bin

$ rpm --eval %{_libexecdir}
/usr/libexec

----

====
Yaygın olarak kullanılan bir makro, %{?dist} makrosudur. Bu makro, derleme esasında hangi dağıtımın kullanıldığına işaret eder. 

Örnek kullanım:

ifdef::community[]
[source,bash]
----
# RHEL 7.x üzerinde
$ rpm --eval %{?dist}
.el7

# Fedora 23 üzerinde
$ rpm --eval %{?dist}
.fc23

----
endif::community[]

Makrolar hakkında daha fazla bilgi almak için: xref:makrolar-hakkinda-daha-fazlasi[].

[[spec-dosyalari-ile-calismak]]
=== SPEC Dosyaları İle Çalışmak

Yazılımları paketlemenin büyük bir kısmı SPEC dosyalarını düzenlemektir. Bu kısımda, SPEC dosyaları oluşturmak ve düzenlemek üzerine konuşacağız. 

Yeni bir yazılımı paketlemek için yeni bir SPEC dosyası oluşturmanız gerekir. Bütün dosyayı en temelden oluşturmak yerine, ``rpmdev-newspec`` aracını kullanabilirsiniz. Bu araç size doldurulmamış bir SPEC dosyası hazırlar ve ihtiyacınıza göre yönetgeleri ve alanları kullanabilirsiniz. 

Bu bölümde, daha önce xref:yazilimi-paketlemeye-hazirlamak[] kısmında gördüğümüz üç farklı Merhaba Dünya programını ele alacağız.  

*   https://github.com/Tarbetu/rpm-paketleme-rehberi/blob/master/%C3%B6rnek-kod/belaba-0.1.tar.gz[belaba-0.1.tar.gz]

*   https://github.com/Tarbetu/rpm-paketleme-rehberi/blob/master/%C3%B6rnek-kod/pelaba-0.1.1.tar.gz[pelaba-0.1.1.tar.gz]

*   https://github.com/Tarbetu/rpm-paketleme-rehberi/blob/master/%C3%B6rnek-kod/celaba-1.0.tar.gz[celaba-1.0.tar.gz]

**   https://github.com/Tarbetu/rpm-paketleme-rehberi/blob/master/%C3%B6rnek-kod/celaba-ciktisi-ilk-yama.patch[celaba-ciktisi-ilk-yama.patch]

Hepsini ``~/rpmbuild/SOURCES`` içine yerleştirin.

Üç dosya için de bir SPEC dosyası hazırlayın.
Create a SPEC file for each of the three programs:

NOTE: Bazı yazılımcı odaklı metin düzenleyicileri ``.spec`` dosyasını önceden hazırlayabilir. ``rpmdev-newspec`` aracı ise düzenleyiciden bağımsız bir yol sunar ki bu rehberde kullanmamızın nedeni budur.

[source,bash]
----
$ cd ~/rpmbuild/SPECS

$ rpmdev-newspec belaba
belaba.spec created; type minimal, rpm version >= 4.11.

$ rpmdev-newspec celaba
celaba.spec created; type minimal, rpm version >= 4.11.

$ rpmdev-newspec pelaba
pelaba.spec created; type minimal, rpm version >= 4.11.

----
``~/rpmbuild/SPECS/`` dizini artık üç farklı SPEC dosyasını içeriyor. Bunlar, ``belaba.spec``, ``celaba.spec`` ve ``pelaba.spec``'tir. 

Dosyaları gözden geçirebilirsiniz. xref:spec-dosyasi-nedir[] kısmında gördüğünüz yönergeleri bu dosyalarda görebilirsiniz. Sonraki bölümlerde, bu SPEC dosyalarını kendiniz dolduracaksınız. 

ifdef::community[]
[NOTE]
====
``rpmdev-newspec`` aracı herhangi bir dağıtıma özgü standartları ve eğilimleri göz önünde bulundurmaz. Fakat bu belge Fedora, CentOS ve RHEL'i hedeflediğinden şu detayları fark edebilirsiniz: 

* _CentOS_ (7.0'dan önceki sürümler) veyahut https://getfedora.org/[Fedora] (18'den önceki sürümler) üzerinde çalışırken ``rm $RPM_BUILD_ROOT`` komutuna denk gelebilirsiniz. Biz, diğer makrolarla tutarlılıkk sağlamak açısından ``%{buildroot}`` kullanmayı ``$RPM_BUILD_ROOT`` kullanmaya tercih ederiz. 

====
endif::community[]

Üç paketlenecek olan üç yazılımın özetilerini aşağıda görebilirsiniz. Her birisi detaylıca tarif edilmiştir. Paketleme için gereken ihtiyacınıza göre özetleyebilir ya da farklı paketleme yöntemlerini keşfetmek için hepsini birden okuyabilirsiniz. 

[cols="15%,85%"]
|====
| Yazılım Adı    | Açıklama
| belaba         | Ham olarak yorumlanan bir programlama dilinde yazılmış bir yazılım. Kaynak kodunun derlenmeye ihtiyacı olmadığı, yalnızca kurulmayı ihtiyaç olduğu bir durumda ne yapılması gerektiğine örnektir. Eğer önceden derlenmiş ikili bir paketin kurulması gerekiyorsa, ikili dosyalar yalnızca bir dosya olduğu için bu kısma göz atabilirsiniz.  inceleyebilirsiniz. 
| pelaba         | Bayt derlenen ve yorumlanan bir programlama dilinde yazılmış bir yazılım. Bayt derlenen kaynak kodunun nasıl derlenmesi ve kurulması gerektiğine örnektir. 
| celaba         | Yerel olarak derlenen bir programlama dilinde yazılmış bir yazılım. Kaynak kodundan makine koduna programın nasıl derlenmesi gerektiğine ve çıktı olarak gelen çalıştırılabilir dosyaların nasıl kurulması gerektiğine örnektir. 
|====

[[spec-dosyalari-ile-calisma-belaba]]
==== belaba

İlk SPEC dosyamız, xref:yazilimi-paketlemeye-hazirlamak[] kısmında daha önce karşılaştığımız, bash kabuk betiği ile yazılmış olan belaba. 

Şunları yaptığınızdan emin olun. 

. ``belaba`` kaynak kodunu ``~/rpmbuild/SOURCES/`` kısmına yerleştirdiğinize dikkat edin. Bilgi için: xref:spec-dosyalari-ile-calismak[].

. Doldurulmamış SPEC dosyasını ``~/rpmbuild/SPECS/belaba.spec`` konumunda olduğuna emin olun. Bu dosyanın içerisinde şunlar olmalı:

+
[source,specfile]
----
Name:           belaba
Version:
Release:        1%{?dist}
Summary:

License:
URL:
Source0:

BuildRequires:
Requires:

%description

%prep
%setup -q

%build
%configure
make %{?_smp_mflags}

%install
rm -rf $RPM_BUILD_ROOT
%make_install

%files
%doc

%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org>
-

----

Şimdi, ``belaba`` RPMlerini oluşturmak için ``~/rpmbuild/SPECS/belaba.spec`` dosyasını düzenleyelim:

. ``Name``, ``Version``, ``Release``, ve ``Summary`` yöngergelerini doldurun:
+
* ``Name`` yönergesi hâlihazırda ``rpmdev-newspec`` tarafından dolduruldu.
+
* ``Version`` yönergesi yazılımının sürümünü belirtmelidir. Sevimli kaynak kodumuz ``belaba`` için bu, ``0.1``.
+
* ``Release``, otomatik olarak ilk değer olan ``1{%dist}`` olarak ayarlandı. Eğer yazılımın sürümünde bir değişiklik olmadan yeni bir güncelleme olursa, mesela ki yeni bir yama, bu sayı tek tek arttırılmalıdır. Yeni sürümlerde ``Release`` rakamı tekrar ``1`` olmalıdır. Örneğin eğer belaba'nın ``0.2`` sürümü yayınlanırsa, ``Release`` tekrardan ``1{%dist} olarak ayarlanmalıdır. _disttag_ makrosu ise xref:rpm-makrolari[] kısmında detaylıca anlatılmıştır. 
+
* ``Summary``, yazılımın ne olduğu anlatan tek satırlık, kısa bir açıklamadır. 
+
Düzenlemelerinizden sonra, SPEC dosyasının ilk kısmı şuna benzemelidir:
+
[source,specfile]
----
Name:           belaba
Version:        0.1
Release:        1%{?dist}
Summary:        Bash ile Yazılmış Bir Merhaba Dünya örneği

----
+
``License``, ``URL`` ve ``Source0`` yönergelerini doldurun:
+
* ``License`` kısmı, yazılımın kaynak kodundaki 
ifdef::community[https://tr.wikipedia.org/wiki/Yazılım_lisansı[Software License]]
ifdef::rhel[Software License]
lisansı ile ilişkili olmalıdır. 
+
ifdef::community[]
``License`` bölümü için şu formatı takip ediniz:
https://fedoraproject.org/wiki/Licensing:Main[Fedora License Guidelines]
endif::community[]
+
Biz örnek olması için ``GPLv3+`` kullanacağız. 
+
* ``URL`` bölümü, yazılımın yayınlandığı İnternet adresine adresini gösterir. Örneğin: ``https:://example.com/belaba``. Yine de tutarlılık olması açısından, %{name} makrosunu tercih edin ve ``https://example.com/%{name}`` şeklinde kullanın.
+
* ``Source0`` yöngergesi, kaynak kodunun yayınlandığı İnternet adresini içerir. Doğrudan paketlenecek yazılımın indirilmek için yayınlandığı adresi içermelidir. Bu örnekte, temsilen ``https://example.com/belaba/releases/belaba-0.1.tar.gz`` adresini kullanacağız. Elbette ki %{name} makrosunu da kullanacağız. Ayrıca, %{version} makrosunu da sürüm değişikliklerine uyum sağlamak için kullacağız. Sonuç olarak girdimiz şu şekli alacaktır:
``https://example.com/%{name}/releases/%{name}-%{version}.tar.gz``
+
Değişikliklerinizden sonra, SPEC dosyasının ilk kısmı şu şekilde görünmelidir:
+
[source,specfile]
----
Name:           belaba
Version:        0.1
Release:        1%{?dist}
Summary:        Bash ile Yazılmış Bir Merhaba Dünya örneği

License:        GPLv3+
URL:            https://example.com/%{name}
Source0:        https://example.com/%{name}/release/%{name}-%{version}.tar.gz

----
+
. ``BuildRequires`` ve ``Requires`` yönergelerini doldurmak ve ``BuildArch`` yönergesini eklemek:
+
* ``BuildRequires``, paket için derleme zamanı bağımlılıklarını belirtir. ``belaba``'nın derlenmesi için hiçbir adıma gerek yoktur, çünkü Bash ham hâlde yorumlanan bir programlama dilidir ve yalnızca dosyaların sisteme kurulması yeterlidir. Yapılacak tek şey, bu yönergeyi silmektir. 
+
* ``Requires`` ise paketlenmiş programın çalışması için gereken bağımlılıkları belirtir. ``belaba`` betiği için gereken tek bağımlılık, çalıştırılması için gereken ``bash`` kabuk ortamıdır. Bu yüzden, bu yönergeye ``bash`` yazarak bunu belirteceğiz.  
+
* Bu program yorumlanan bir dilde yazıldığından dolayı mimari açısından herhangi bir bağlantı gerektirmeyecektir. ``BuildArch`` direktifini ekleyip buna ``noarch`` değeri vereceğiz. Bu değer, RPM paketinin herhangi bir işlemci mimarisi üzerinde çalışabileceğini belirtecektir. 
+
Değişikliklerinizden sonra, SPEC doyasının ilk kısmı şu şekilde görünmelidir:
+
[source,specfile]
----
Name:           belaba
Version:        0.1
Release:        1%{?dist}
Summary:        Bash ile Yazılmış Bir Merhaba Dünya örneği

License:        GPLv3+
URL:            https://example.com/%{name}
Source0:        https://example.com/%{name}/release/%{name}-%{version}.tar.gz

Requires:       bash

BuildArch:      noarch

----
. ``%description``, ``%prep``, ``%build``, ``%install``, ``%files``, ve ``%license`` kısımlarını doldurun. Bu yönergeler "Konu başlıkları" olarak da düşünülebilir, zira bu yönergeler çoklu satır hâlinde belirlenebilir, çalıştırılması gereken komutları belirleyebilir ve çoklu talimatlar bildirebilirler. 
+
* ``%description`` kısmı dosyanın uzun bir anlatımını içerir. ``Summary`` yönergesinden farkı, bir veya birden çok paragrafı barındırmasıdır. Bu örneğimizde kısa bir açıklamayla geçiştireceğiz. 
+
* ``%prep`` kısmı, derleme için uygun ortamı belirtir. Bu, arşivlenmiş kodun dışarı açılması, yamaların uygulanması ve SPEC dosyasının ileri safhalarında kullanmak üzere kaynak kodundaki belirli bir bilgiyi almak için taramak olabilir. Bu bölümde yalnızca ``%setup -q`` gömülü makrosunu kullanacağız. 
+
* ``%build`` kısmı ise, paketlediğimiz yazılımın nasıl derlenmesi gerektiğini belirtir. ``bash`` diliyle yazılan dosyaların derlenmeye ihtiyacı olmadığı için, basitçe bu kısmı silip boş bırakacağız. 
+
* ``%install`` kısmı ise ``rpmbuild``'in dosyaları nasıl kurması gerektiğini bildiren yönergeleri içerir. Bu dizinde inşa edilen dosyalar ``BUILDROOT`` dizinine eklenir. Bu dizin, bir 
ifdef::community[https://en.wikipedia.org/wiki/Chroot[chroot]]
ifdef::rhel[chroot]
temel dizinidir ve paketi kuran tarafın kök dizinini temsil eder. Burada, kurduğumuz dosyaların dizinlerini oluşturmamız gerekir. 
+
``belaba`` için yalnızca hedef dizini kurmamız ve ``bash`` betiğini yerleştirmemiz gerektiği için ``install`` komutunu kullanacağız. RPM makroları bu işe kolay yoldan yapmamız için yardımcı olacaktır. . 

+
``%install`` kısmı düzenlemeleri bitirdikten sonra şöyle görünecektir: 
+
[source,specfile]
----
%install

mkdir -p %{buildroot}/%{_bindir}

install -m 0755 %{name} %{buildroot}/%{_bindir}/%{name}

----
+
* ``%files`` kısmı, paketinizin son kullanıcının sistemine yerleştireceği dosyaların tam konumunu belirtir. Yalnızca ``belaba`` dosyasını kuracağımız için, konumumuz ``/usr/bin/belaba``'dır ki bunu RPM Makroları ile ``%{_bindir}/%{name} olarak kısaltabiliriz. 

+
* Aynı zamanda, gömülü makrolar aracılığıyla dosyaların ne gibi görevleri olduğunu belirtebilirsiniz.
Örneğin LICENSE dosyasının yazılım lisansı olduğunu belirtmek için %license makrosunu kullanabilirsiniz.
Bu, ``rpm`` komutu aracılığıyla paketin üstveriyi sorgulandığında kolaylık sağlar. 
+
Değişikliklerinizden sonra, %files kısmı şu şekilde görünecektir:
+
[source,specfile]
----
%files
%license LICENSE
%{_bindir}/%{name}

----
+
. Son kısım olan ``%changelog`` kısmı, her Sürüm-Yayın değişikliği için tarif damgalı girdileri listeler. Bu günlük, paketleme değişikliklerini içerir, yazılım değişikliğini değil. Mesela, paketleme değişiklikleri için örnekler: yama ekleme, inşa sürecini değiştirme vs.

Ç.N: ``%changelog`` içerisindeki değişiklikleri ve tarih damgasını İngilizce yazmanız paketi inceleyecek yabancı kullanıcılar için kolaylık sağlayacaktır. 

+
İlk satır için şu biçimi takip ediniz: 
+
`* HaftanınGünü Ay Gün Yıl İsim Soyisim <eposta> - Sürüm-Yayın`
+
Değişiklikleri bildirirken şu kuralları uygulayın:
+
--
* Her satır girdi birden fazla öğe içerebilir - Her madde için bir tane 
* Her madde için yeni bir satıra geçilmelidir.
* Her madde ``-`` ile başlamalıdır. 
--
+
Tarih damgalanmış örnek bir girdi:
+
[source,specfile]
----
%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org> - 0.1-1
- İlk belaba paketi
- 0.1-1 sürüm - yayını için öylesine bir ikinci madde

----

Ve, **belaba** için bütün SPEC dosyasını yazmış bulunmaktasınız. **belaba** için yazmış olduğunuz dosya buna benzemelidir:


[source,specfile]
----
Name:           belaba
Version:        0.1
Release:        1%{?dist}
Summary:        Bash ile Yazılmış Bir Merhaba Dünya örneği

License:        GPLv3+
URL:            https://www.example.com/%{name}
Source0:        https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz

Requires:       bash

BuildArch:      noarch

%description
Bash ile yazılmış Merhaba Dünya örneği için 
satırlara sığmayan
epey uzun bir 
tanıtım yazısı

%prep
%setup -q

%build

%install

mkdir -p %{buildroot}/%{_bindir}

install -m 0755 %{name} %{buildroot}/%{_bindir}/%{name}

%files
%license LICENSE
%{_bindir}/%{name}


%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org> - 0.1-1
- First belaba package


----

Sonraki kısım, nasıl RPM derlenmesi gerektiğini içerir.

[[spec-dosyalari-ile-calisma-pelaba]]
==== pelaba

Hazırlayacağımız ikinci SPEC dosyası, https://www.python.org/[Python] ile hazırlanmış olan örnek programımız için. İndirdiğimiz (ya da xref:yazilimi-paketlemeye-hazirlamak[] kısmında hazırladığımız) dosyayı  ``~/rpmbuild/SOURCES/`` dosyasına yerleştiriyoruz ve ``~/rpmbuild/SPECS/pelaba.spec`` dosyasını oluşturup düzenliyoruz.

Bu düzenlemeye girişmeden önce, bayt derlenerek yorumlanan dillere dair önemli bir detaydan bahsetmemiz gerekiyor. Yazılımı bayt-derlediğimiz için 
ifdef::community[https://en.wikipedia.org/wiki/Shebang_%28Unix%29[mevzu]]
ifdef::rhel[shebang]
olarak isimlendirilen yapıyı kullanamıyoruz. Bu yapı, bayt derlenmeyen kabul betikleri ve https://www.python.org/[Python] gibi dillerin ufak çaplı kodları için yaygın olarak tercih edilen bir yoldur. Bizim tek satırlık kodumuz için bayt derleme işi anlamsız görünebilir, fakat yüzlerce koddan oluşan büyük çaptaki yazılım projeleri için bu iş performans açısından oldukça faydalıdır. 

NOTE: Bayt derlenmiş kodu çağıran betiği hazırlamak veyahut yazılıma bayt derlenmemiş koda giriş noktası oluşturmak, yazılımcıların paketi yayına çıkartmadan önce sıklıkla yaptıkları iştir. Ancak kimi durumlarda böyle bir giriş noktası hazırlanmamış olabilir ve bu alıştırma bu tarz durumlarda ne yapmanız gerektiğini gösterir. https://www.python.org/[Python] kodunun normalde nasıl yayınlandığını ve dağıtıldığını öğrenmek istiyorsanız lütfen https://docs.python.org/3/library/distribution.html[Yazılım Paketleme ve Dağıtma] belgelerini inceleyiniz. 

Bayt derlenmiş yazılıma bir giriş noktası hazırlamak için ufak bir kabuk betiği hazırlayacağız ve bu betiği SPEC dosyasının içerisine dâhil ekleyeceğiz. Aynı zamanda bu SPEC dosyası içerisinde nasıl betik kabuğu kodlarını çalıştırdığımıza dair bir örnek olmuş olacak. Bu işin nasıl yapılacağına dair detayları ``%install`` kısmında inceleyeceğiz. 

Hadi bir adım ileri çıkalım ve ``~/rpmbuild/SPECS/pelaba.spec`` dosyasını incelemek üzere açalım. 

Aşağıdaki örnek dosya ``rpmdev-newspec`` komutunun bize verdiği şablondur. 


[source,specfile]
----
Name:           pelaba
Version:
Release:        1%{?dist}
Summary:

License:
URL:
Source0:

BuildRequires:
Requires:

%description

%prep
%setup -q

%build
%configure
make %{?_smp_mflags}

%install
rm -rf $RPM_BUILD_ROOT
%make_install

%files
%doc

%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org>
-

----

Tıpkı ilk örnek örnekte olduğu gibi, belgenin en tepesinde yer alan ``Name``,
``Version``, ``Release``, ``Summary`` yönergeleriyle düzenlemeye başlayalım. ``rpmdev-newspec`` komutu gerekli bilgiyi önceden sağladığı için ``Name`` yönergesi önceden belirtilmiş oldu. 

İlk iş, ``Version`` yönergesini __pelaba__'nın sürüm numarasına eşleştirmek olsun. Bu yazılım numarası, indirdiğimiz kod için (veya xref:yazilimi-paketlemeye-hazirlamak[] kısmında gördüğümüz üzere) ``0.1.1``'dir. 

``Release`` hâlihazırda bizim için ``1%{?dist}`` olarak ayarlandı. Ayarlanmış değerin içindeki ``1`` sayısı paket her düzenlendiğinde bir arttırılmak zorundadır, ki bu düzenlemeler bir sorunun düzeltilmesi için yama eklemek olabilir. Fakat yeni bir ``Version`` yayınlandığında bu sayı tekrar ``1``'e geri çekilmelidir. xref:rpm-makrolari[] bölümünü okuyanlar ``%{?dist}`` ile gösterilen __disttag__ makrosunu hemen tanımış olmalıdır.

``Summary``, yazılımın ne olduğunu açıklayan kısa, tek satırlık bir yönergedir. 

SPEC dosyasının ilk kısmında yaptığımız değişikliklerden sonra bu kısım şuna benzemelidir:

[source,specfile]
----
Name:           pelaba
Version:        0.1.1
Release:        1%{?dist}
Summary:        Python ile Yazılmış Bir Merhaba Dünya örneği

----

Şimdi, ``rpmdev-newspec`` komutunun ``License``, ``URL``, ``Source0`` şeklinde grupladığı ikinci kısma bakalım. 

ifdef::community[]
``License`` kısmı, yazılımcının kaynak kodu için belirttiği https://tr.wikipedia.org/wiki/Yazılım_lisansı[Yazılım Lisansıdır]. SPEC dosyasında kullanılan olan lisans etiketleri RPM tabanlı https://tr.wikipedia.org/wiki/Linux dağıtımları için farklılık gösterir. Biz, https://fedoraproject.org/wiki/Licensing:Main[Fedora Lisanslama Rehberi] için geçerli olan yazım standartlarını kullanacağız ve bu programımız için örnek olarak seçtiğimiz tarz ``GPLv3+``'dır.
endif::community[]

ifdef::rhel[]
``Licence`` kısmı, kaynak kodunda belirtilmiş yazılım lisansıdır. SPEC dosyasında kullanılan yazım tarzı çeşitli RPM tabanlı Linux dağıtımları için farklılık gösterir. 
endif::rhel[]

``URL`` yönergesi, yazılımın anasayfasına giden bağlantıyı içerir. Bu bağlantı, kaynak koda giden bağlantıyı değil ürünün, projenin veyahut şirketin ana sayfasına giden bağlantı olmalı ve bu bağlantıdan yazılımın ilgili parçası hakkında daha fazla bilgiye ulaşılmalıdır. Şimdilik örnek olması açısından ``https://example.com/pelaba`` adresini seçiyoruz. Ancak, SPEC dosyasının diğer parçaları arasında tutarlılık olması için adresteki yazılım ismini ``%{name}`` RPM makrosu ile değiştireceğiz. 

``Source0`` kaynak kodu yazılım kodunun indirilebileceği adresi işaret eder. Bu bağlantı, paketlenecek olan kaynak kodun ilgili sürümüne yönlendirmelidir. Aynı şekilde, bu yalnızca bir örnek olduğu için şöyle bir örnek kullanacağız:
``https://example.com/pelaba/releases/pelaba-0.1.1.tar.gz``

Bahsedilmelidir ki, tamamen sabit bir şekilde belirtilmiş bir bağlantı ileride yayınlanacak olan sürümler sıkıntı yaratacaktır ve adresteki ``0.1.1`` kısmı muhakkak değişecektir. Bir SPEC dosyası yalnızca tek bir sürüm için hazırlanmaz, yeni sürümlerde de olabilecek en az değişiklikle tekrar kullanılır. Bu yüzden, kodu hazırlarken adres sabit olarak değil ``https://example.com/%{name}/releases/%{name}-%{version}.tar.gz`` biçimiyle yazılır. 

Değişikliklerin ardından, SPEC dosyanızın üst tarafı şuna benzemelidir:

[source,specfile]
----
Name:           pelaba
Version:        0.1.1
Release:        1%{?dist}
Summary:        Python ile Yazılmış Bir Merhaba Dünya örneği

License:        GPLv3+
URL:            https://www.example.com/%{name}
Source0:        https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz

----

Ardından, ``BuildRequires`` ve ``Requires`` isimli iki yönergeyi ele alacağız, bu iki yönerge de paketin bağımlılıklarının belirler. Fakat, ``BuildRequires`` paketin **inşa edilmesi** için gereken bağımlılıkları gösterirken ``Requires`` paketin düzgünce **çalışması** için gerekli olan bağımlılıklara işaret eder.

Bu örnekte, kaynak kodunu bayt olarak derlemek üzere ``python`` paketine ihtiyacımız var. Aynı zamanda bayt-derlenmiş kodu çalıştırmak için ``python`` paketine ihtiyacımız var ve bunu belirtmek ``Requires`` direktifini kullanacağız. Aynı şekilde, paketimize hazırlayacağımız ufak bir giriş betiğini çalıştırmak için ``bash`` paketine de ihtiyacımız var.

Eklememiz gereken bir diğer şey ise, yorumlanan bir programlama dili üzerinde çalıştığımız için ``BuildArch`` direktifini ``noarch`` olarak belirtmemiz gerekiyor, böylece RPM bu paketin bir işlemci mimarisine bağımlı olmadığını anlamış olacak. 

Düzenlemlerin ardından, SPEC dosyanızın üst kısmı şuna benzemelidir:

[source,specfile]
----
Name:           pelaba
Version:        0.1.1
Release:        1%{?dist}
Summary:        Python ile Yazılmış Bir Merhaba Dünya örneği

License:        GPLv3+
URL:            https://www.example.com/%{name}
Source0:        https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz

BuildRequires:  python
Requires:       python
Requires:       bash

BuildArch:      noarch
----

Bundan sonraki yönergeler, "gövde başlıklar" olarak düşünülebilir. Çünkü bu yönergeler birden çok satırı, talimatı ve betiklendirilmiş görevleri kapsamakta. Bu yönergeleri de yine daha önceki yönergelerimizi nasıl düzenliyorsak aynı şekilde düzenleyeceğiz. 

``%description``, ``Summary`` yönergesine kıyasla paketlenecek yazılım hakkında çok daha uzun bir açıklamayı içerir. Bu örneğimizde çok uzun bir tanıtım yazısı yazmayacağız, ancak bu kısım dilenirse tüm bir paragrafı ya da paragrafları kapsayabilir. 

``%prep``, "Hazırlamak" kelimesinin İngilize karşılığı olan __prepare__ kelimesinin kısaltmasıdır. Yazılımı derlemek için gerekli olan ortamı veya çalışma alanını inşa etmek için kullanılır. Çoğu zaman bu işler; sıkıştırılmış arşivlerin açılması, yamaların uygulanması ve kaynak kodu içerisindeki bilgiyi SPEC dosyasının sonraki bölümlerinde okunması üzerine okumaktır. Bu bölümde kısaca işimizi görmek üzere ``%setup -q`` makrosunu kullanacağız. 

``%build``, paketlerin derlenmesi için ne yapılması gerektiğini içerir. Örneğimizde kaynak kodunun nasıl derlenmesi gerektiğine dair komutları uygulayacağız. xref:yazilimi-paketlemeye-hazirlamak[] kısmını okumuş okuyucular bu kodu tanıyacaktır. 

SPEC dosyamızdaki ``%build`` kısmı şuna benzemelidir: 

[source,specfile]
----
%build

python -m compileall pelaba.py

----

``%install`` kısmı ise ``rpmbuild``'in dosyaları nasıl kurması gerektiğini bildiren yönergeleri içerir. Bu dizinde inşa edilen dosyalar ``BUILDROOT`` dizinine eklenir. Bu dizin, bir 
ifdef::community[https://en.wikipedia.org/wiki/Chroot[chroot]]
ifdef::rhel[chroot]
temel dizinidir ve paketi kuran tarafın kök dizinini temsil eder. Burada, kurduğumuz dosyaların dizinlerini oluşturmamız gerekir. Aynı şekilde, RPM Makroları burada yapılan işleri sabit bir şekilde kodlamadan yapmamıza yardımcı olur. 

Daha önce, dosyanın 
ifdef::community[https://en.wikipedia.org/wiki/Shebang_%28Unix%29[mevzu]]
ifdef::rhel[shebang]
isimli kısmını kaybettiğimizi söylemiştik, bundan dolayı bayt derlenmiş kodumuz için aynı işi yapan bir betik hazırlamamız gerekmekte. Bunu yapmak için çok fazla yolumuz var, bunlardan birisi bir betik hazırlayıp ayrı bir ``SourceX`` yönergesiyle bunu belirtmek ve  bu örnekte tercih edeceğimiz şekilde SPEC dosyası içerisinde bir dosya oluşturmaktır. Bu örneği tercih etmemizin sebebi SPEC dosyasının da betik yazılabilir bir dosya olduğunu göstermektir. Yapacağımız şey, https://www.python.org/[Python] bayt-derlenmiş kodunu 
ifdef::community[https://en.wikipedia.org/wiki/Here_document["here" belgesi]]
ifdef::rhel["here" document]
ile çalıştırmak. Aynı zamanda bayt-derlenmiş dosyayı bir sistemin erişebileceği bir kütüphane dizinine kurmamız gerekmektedir. 


NOTE: Fark ettiğiniz üzere burada kütüphane adresini elle belirtiyoruz. Bu durumdan kaçınmanın bir çok yolu var ve bunların ciddi bir kısmı <<gelismis-konular>> altındaki xref:makrolar-hakkinda-daha-fazlasi[] kısmında bahsediliyor, paketlenen yazılımın yazıldığı programlama diline uygun olarak. Bu örnekte çok fazla kafa karıştırmamak üzere kütüphane adresini elle yazmayı tercih ediyoruz. 

``%install`` kısmı düzenlemelerin ardından şu şekilde görünmelidir:

[source,specfile]
----
%install

mkdir -p %{buildroot}/%{_bindir}
mkdir -p %{buildroot}/usr/lib/%{name}

cat > %{buildroot}/%{_bindir}/%{name} <<-EOF
#!/bin/bash
/usr/bin/python /usr/lib/%{name}/%{name}.pyc
EOF

chmod 0755 %{buildroot}/%{_bindir}/%{name}

install -m 0644 %{name}.py* %{buildroot}/usr/lib/%{name}/

----

``%files`` kısmı, bu RPM paketinin içerdiği dosyaları ve paketin kurulacağı sisteme yerleştirilmesi planlanan dosyaları belirttiğimiz kısımdır. 

Dikkat etmeniz gereken bir husus, bu kısmın ``%{buildroot}``'a göre yazılmaması gerektiğidir. Bu kısımdaki dosyalar, paketi kuran kullanıcının sisteminde kurulumdan sonra belirlenecek tam konuma göre belirtilmelidir. Bu yüzden, ``pelaba`` dosyasının sistemdeki konumunu belirtirken ``%{_bindir}/pelaba`` olarak belirtmemiz gerekmektedir. Aynı zamanda, dosyaları içine yerleştirdiğimiz bir kütüphane dizinin bu paket tarafından "sahiplenildiğini" belirtmek üzere bir ``%dir`` tanımlamamız gerekmektedir. 

Ayrıca bu kısımda, bir dosyanın içeriğinde ne olduğunu belirtmek üzere bazı gömülü makroları kullanmaya ihtiyacınız olacaktır. Bu, ``rpm`` komutunun çıktısını sorgulamak isteyen sistem yöneticileri ve son kullanıcılar için oldukça kullanışlı olabilir. Burada kullanacağımız ``%license`` gömülü makrosu, ``rpmbuild``'e bu dosyanın yazılım lisansını içerdiğini bildirecektir. 

``%files`` kısmı, düzenlemenizin ardından şu şekilde görünmelidir:

[source,specfile]
----
%files
%license LICENSE
%dir /usr/lib/%{name}/
%{_bindir}/%{name}
/usr/lib/%{name}/%{name}.py*

----

Son kısım olan ``%changelog``, tarih damgalı girdilerin Sürüm-Yayın değişikliklerinde ne olduğunu günlüklemek içindir. Bu günlükte her değişikliğin yazılması gerekmez ancak her önemli paketleme değişikliklerinin belirtilmesi gereklidir. Örneğin, bir paket içerisindeki yazılımın paketlemeye ihtiyacı varsa veya ``%build`` kısmında gösterilen derleme yönteminin değiştirilmesi gerekiyorsa burada bilgi verilebilir. Her bir girdi birden fazla maddeyi içerebilir, ve her madde ``-`` karakteriyle başlayan yeni bir satırla başlamalıdır. 
Aşağıda örnek bir girdi görmektesiniz:

[source,specfile]
----
%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org> - 0.1.1-1
- İlk belaba paketi
- 0.1.1-1 sürüm - yayın için öylesine bir ikinci madde

----

Yukarıdaki örnekte dikkat etmelisiniz ki, tarih damgası ``*`` karakteriyle başlamalıdır ve haftanın günü, ay, gün ve yıl ve RPM paketçisi hakkındaki iletişim bilgileri formatıyla hazırlanmalıdır. Ardından, Sürüm (Version) - Yayın'dan (Release) önce ``-`` karakterini yerleştirdik, bu alışılagelen bir yaklaşımdır ancak zorunluluk değildir. 

Ve hepsi bu kadar! **Pelaba** için bütün SPEC dosyasını yazmış bulunmaktayız! Bundan sonraki kısımda bir RPM dosyası nasıl inşa edilir, bunu okuyacaksınız! 

Bütün SPEC dosyası değişikliklerden sonra şuna benzer şekilde görünmelidir:

[source,specfile]
----
Name:           pelaba
Version:        0.1.1
Release:        1%{?dist}
Summary:        Python ile Yazılmış Bir Merhaba Dünya örneği

License:        GPLv3+
URL:            https://www.example.com/%{name}
Source0:        https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz

BuildRequires:  python
Requires:       python
Requires:       bash

BuildArch:      noarch

%description
Python ile yazılmış Merhaba Dünya örneği için 
satırlara sığmayan
epey uzun bir 
tanıtım yazısı

%prep
%setup -q

%build

python -m compileall %{name}.py

%install

mkdir -p %{buildroot}/%{_bindir}
mkdir -p %{buildroot}/usr/lib/%{name}

cat > %{buildroot}/%{_bindir}/%{name} <<-EOF
#!/bin/bash
/usr/bin/python /usr/lib/%{name}/%{name}.pyc
EOF

chmod 0755 %{buildroot}/%{_bindir}/%{name}

install -m 0644 %{name}.py* %{buildroot}/usr/lib/%{name}/

%files
%license LICENSE
%dir /usr/lib/%{name}/
%{_bindir}/%{name}
/usr/lib/%{name}/%{name}.py*


%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org> - 0.1.1-1
- First pelaba package

----

[[spec-dosyalari-ile-calisma-pelaba]]
==== celaba

Üçüncü SPEC dosyamız ise, 
ifdef::community[https://en.wikipedia.org/wiki/C_%28programming_language%29[C]]
ifdef::rhel[C]
programlama dilinde yazılmış olan örneğimiz için. Daha önceden bu örnek programı hazırlamış (ya da indirmiş) ve kaynak kodunu ``~/rpmbuild/SOURCES/`` içerisine yerleştirmiş olmalısınız. 

Hadi bir adım ileri gidelim ve ``~/rpmbuild/SPECS/celaba.spec`` dosyasını açıp boşluklarını doldurmaya başlayalım. 

``rpmdev-newspec`` komutu ile bu dosyayı oluşturabilirsiniz.

[source,specfile]
----
Name:           celaba
Version:
Release:        1%{?dist}
Summary:

License:
URL:
Source0:

BuildRequires:
Requires:

%description

%prep
%setup -q

%build
%configure
make %{?_smp_mflags}

%install
rm -rf $RPM_BUILD_ROOT
%make_install

%files
%doc

%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org>
-

----

Tıpkı daha önceki örneklerimizde yaptığımız gibi, ``rpmdev-newspec`` komutunun dosyanın üst tarafına topladığı yönergelerlerle başlayacağız, bunlar: ``Name``, ``Version``, ``Release``, ``Summary``'dir. ``Name`` isimli yönerge, ``rpmdev-newspec`` tarafından hâlihazırda belirtildiği için düzenlememize gerek yok. 

``Version`` isimli yönerge __celaba__'nın kaynak kodunun sürümüyle eşleşmelidir ki indirdiğimiz (ya da xref:yazilimi-paketlemeye-hazirlamak[] kısmında belirlediğimiz) üzere bu ``1.0``'dır. 

``Release`` hâlihazırda bizim için ``1%{?dist}`` olarak ayarlandı. Ayarlanmış değerin içindeki ``1`` sayısı paket her düzenlendiğinde bir arttırılmak zorundadır, ki bu düzenlemeler bir sorunun düzeltilmesi için yama eklemek olabilir. Fakat yeni bir ``Version`` yayınlandığında bu sayı tekrar ``1``'e geri çekilmelidir. xref:rpm-makrolari[] bölümünü okuyanlar ``%{?dist}`` ile gösterilen __disttag__ makrosunu hemen tanımış olmalıdır.

``Summary`` ise yazılımın ne olduğuna göre tek satırlık, kısa bir açıklamadır. 

İlk düzenlemelerinizin ardından, SPEC dosyasının ilk bölümü şuna benzemelidir. 

After your edits, the first section of the SPEC file should resemble the
following:

[source,specfile]
----
Name:           celaba
Version:        1.0
Release:        1%{?dist}
Summary:        C ile Yazılmış Bir Merhaba Dünya örneği
----

Şimdi, ``rpmdev-newspec`` komutunun grupladığı iki direktiflere göz atalım:
``License``, ``URL`` ve ``Source0``. Aynı zamanda, bu direktiflerin içine ``Source0`` ile yakından alakalı, ``Patch0`` direktifini ekleyeceğiz ki
bu direktif bizim hazırladığımız yamayı yazılıma dâhil edecek. 

ifdef::community[]
``License`` kısmı, yazılımcının kaynak kodu için belirttiği https://tr.wikipedia.org/wiki/Yazılım_lisansı[Yazılım Lisansıdır]. SPEC dosyasında kullanılan olan lisans etiketleri RPM tabanlı https://tr.wikipedia.org/wiki/Linux[Linux] dağıtımları için farklılık gösterir. Biz, https://fedoraproject.org/wiki/Licensing:Main[Fedora Lisanslama Rehberi] için geçerli olan yazım standartlarını kullanacağız ve bu programımız için örnek olarak seçtiğimiz tarz ``GPLv3+``'dır.
endif::community[]
ifdef::rhel[]
``Licence`` kısmı, kaynak kodunda belirtilmiş yazılım lisansıdır. SPEC dosyasında kullanılan yazım tarzı çeşitli RPM tabanlı Linux dağıtımları için farklılık gösterir. 
endif::rhel[]

``URL`` yönergesi, yazılımın anasayfasına giden bağlantıyı içerir. Bu bağlantı, kaynak koda giden bağlantıyı değil ürünün, projenin veyahut şirketin ana sayfasına giden bağlantı olmalı ve bu bağlantıdan yazılımın ilgili parçası hakkında daha fazla bilgiye ulaşılmalıdır. Şimdilik örnek olması açısından ``https://example.com/celaba`` adresini seçiyoruz. Ancak, SPEC dosyasının diğer parçaları arasında tutarlılık olması için adresteki yazılım ismini ``%{name}`` RPM makrosu ile değiştireceğiz. 

``Source0`` yöngergesi, kaynak kodunun yayınlandığı İnternet adresini içerir. Doğrudan paketlenecek yazılımın indirilmek için yayınlandığı adresi içermelidir. Bu örnekte, temsilen ``https://example.com/belaba/releases/celaba-1.0.tar.gz`` adresini kullanacağız. Elbette ki ``%{name}`` makrosunu da kullanacağız. Ayrıca, ``%{version}`` makrosunu da sürüm değişikliklerine uyum sağlamak için kullacağız. Sonuç olarak girdimiz şu şekli alacaktır:
``https://example.com/%{name}/releases/%{name}-%{version}.tar.gz``


Bahsedilmelidir ki, tamamen sabit bir şekilde belirtilmiş bir bağlantı ileride yayınlanacak olan sürümler sıkıntı yaratacaktır ve adresteki ``1.0`` kısmı muhakkak değişecektir. Bir SPEC dosyası yalnızca tek bir sürüm için hazırlanmaz, yeni sürümlerde de olabilecek en az değişiklikle tekrar kullanılır. Bu yüzden, kodu hazırlarken adres sabit olarak değil ``https://example.com/%{name}/releases/%{name}-%{version}.tar.gz`` biçimiyle yazılır. 

Bir sonraki işimiz ise daha önceden hazırladığımız ``.patch`` dosyasını paketimize ``%prep`` kısmında kullanılmak üzere dahil etmek. Bunun için, 
`Patch0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; celaba-ciktisi-ilk-yama.patch`` satırını SPEC dosyamıza ekleyeceğiz. 

Bütün değişikliklerden sonra, SPEC dosyanızın üst kısmı şuna benzemelidir:

[source,specfile]
----
Name:           celaba
Version:        1.0
Release:        1%{?dist}
Summary:        C ile Yazılmış Bir Merhaba Dünya örneği

License:        GPLv3+
URL:            https://www.example.com/%{name}
Source0:        https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz

Patch0:         celaba-ciktisi-ilk-yama.patch

----

Bundan sonraki yönergelerimiz, ``BuildRequires`` ve ``Requires`` yönergeleridir ki bu satırlar gerekli paketleri sıralar. 
Fakat ``BuildRequires``, ``rpmbuild``'e paketin **inşa edilmesi** için ne gerektiğini bildirirken ``Requires`` paketin **çalışması** için hangi paketlere ihtiyaç olduğunu bildirir. 

Bu örnekte kaynak kodunu derlemek üzere ``gcc`` ve ``make`` paketine ihtiyacımız olacak. Yazılımın çalışması için gereken bağımlılıklar ise ``rpmbuild`` tarafından sağlanmakta, zira programımız standart
ifdef::community[https://tr.wikipedia.org/wiki/C_(programlama_dili)[C]]
ifdef::rhel[C]
kütüphaneleri dışında hiçbir şeyi gerektirmemekte ve bundan dolayı herhangi bir şeyi ``Requires`` yönergesi içerisinde belirtmemize gerek yok, bu yönergeyi SPEC içerisinden çıkartabiliriz.

Düzenlemenizin ardından, SPEC dosyanızın üst tarafı şuna benzemelidir:

[source,specfile]
----
Name:           celaba
Version:        1.0
Release:        1%{?dist}
Summary:        C ile Yazılmış Bir Merhaba Dünya örneği

License:        GPLv3+
URL:            https://www.example.com/%{name}
Source0:        https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz

Patch0:         celaba-ciktisi-ilk-yama.patch

BuildRequires:  gcc
BuildRequires:  make

----

Bundan sonraki yöenrgeler, 

Bundan sonraki yönergeler, "gövde başlıklar" olarak düşünülebilir. Çünkü bu yönergeler birden çok satırı, talimatı ve betiklendirilmiş görevleri kapsamakta. Bu yönergeleri de yine daha önceki yönergelerimizi nasıl düzenliyorsak aynı şekilde düzenleyeceğiz. 

``%description``, ``Summary`` yönergesine kıyasla paketlenecek yazılım hakkında çok daha uzun bir açıklamayı içerir. Bu örneğimizde çok uzun bir tanıtım yazısı yazmayacağız, ancak bu kısım dilenirse tüm bir paragrafı ya da paragrafları kapsayabilir. 

``%prep``, "Hazırlamak" kelimesinin İngilize karşılığı olan __prepare__ kelimesinin kısaltmasıdır. Yazılımı derlemek için gerekli olan ortamı veya çalışma alanını inşa etmek için kullanılır. Çoğu zaman bu işler; sıkıştırılmış arşivlerin açılması, yamaların uygulanması ve kaynak kodu içerisindeki bilgiyi SPEC dosyasının sonraki bölümlerinde okunması üzerine okumaktır. Bu bölümde kısaca işimizi görmek üzere ``%setup -q`` makrosunu kullanacağız. 

``%build`` ise paketlediğimiz yazılımın nasıl derlenmesi/inşa edilmesi gerektiğini bildiren kısımdır. 
ifdef::community[https://tr.wikipedia.org/wiki/C_(programlama_dili)[C]]
ifdef::rhel[C] 
ile yazdığımız programımız için basit bir ``Makefile`` yazdığımızdan dolayı, basit bir şekilde ``rpmdev-newspec`` komutunun bizim için hazırladığı http://www.gnu.org/software/make/[GNU make] komutunu kullanabiliriz. Ancak, bir 
ifdef::community[https://tr.wikipedia.org/wiki/Configure["configure" (yapılandırma) betiği]
ifdef::rhel["configure" (yapılandırma betiği]
hazırlamadığımız için ``%configure`` yönergesini kaldırmamız gerekmekte. 

Kodumuzun ``%build`` kısmı buna benzemelidir:


[source,specfile]
----
%build
make %{?_smp_mflags}
----

``%install`` kısmı ise ``rpmbuild``'in dosyaları nasıl kurması gerektiğini bildiren yönergeleri içerir. Bu dizinde inşa edilen dosyalar ``BUILDROOT`` dizinine eklenir. Bu dizin, bir 
ifdef::community[https://en.wikipedia.org/wiki/Chroot[chroot]]
ifdef::rhel[chroot]
temel dizinidir ve paketi kuran tarafın kök dizinini temsil eder. Burada, kurduğumuz dosyaların dizinlerini oluşturmamız gerekir. Buradaki RPM Makroları, bu işi gerçekleştirirken değişmez kalıp kodlardan kaçınmamıza yardımcı olur. 
sabit kodlardan kaçınmamıza yardımcı olur.

Tekrar bahsetmek gerekirse, elimizdeki ``Makefile`` dosyasındaki kurulum talimatları kolaylıkla ``rpmdev-newspec`` tarafından sağlanmış olan ``%make_install`` makrosu aracılığıyla kurulabilir. 

Bütün değişikliklerden sonra ``%install`` yönergesi şu şekilde görünmelidir:

[source,specfile]
----
%install
%make_install

----

``%files`` kısmı, bu RPM paketinin içerdiği dosyaları ve paketin kurulacağı sisteme yerleştirilmesi planlanan dosyaları belirttiğimiz kısımdır. 

Dikkat etmeniz gereken bir husus, bu kısmın ``%{buildroot}``'a göre yazılmaması gerektiğidir. Bu kısımdaki dosyalar, paketi kuran kullanıcının sisteminde kurulumdan sonra belirlenecek tam konuma göre belirtilmelidir. Bu yüzden, ``celaba`` dosyasının sistemdeki konumunu belirtirken ``%{_bindir}/celaba`` olarak belirtmemiz gerekmektedir. 

Ayrıca bu kısımda, bir dosyanın içeriğinde ne olduğunu belirtmek üzere bazı gömülü makroları kullanmaya ihtiyacınız olacaktır. Bu, ``rpm`` komutunun çıktısını sorgulamak isteyen sistem yöneticileri ve son kullanıcılar için oldukça kullanışlı olabilir. Burada kullanacağımız ``%license`` gömülü makrosu, ``rpmbuild``'e bu dosyanın yazılım lisansını içerdiğini bildirecektir.

``%files`` kısmı, son değişikliklerden sonra şu şekilde görünmelidir: 

[source,specfile]
----
%files
%license LICENSE
%{_bindir}/%{name}

----

Son kısım olan ``%changelog``'da, tarih damgalı girdiler Sürüm-Yayın değişikliklerinde ne olduğunu günlüklemek içindir. Bu günlükte her değişikliğin yazılması gerekmez ancak her önemli paketleme değişikliklerinin belirtilmesi gereklidir. Örneğin, bir paket içerisindeki yazılımın paketlemeye ihtiyacı varsa veya ``%build`` kısmında gösterilen derleme yönteminin değiştirilmesi gerekiyorsa burada bilgi verilebilir. Her bir girdi birden fazla maddeyi içerebilir, ve her madde ``-`` karakteriyle başlayan yeni bir satırla başlamalıdır. 
Aşağıda örnek bir girdi görmektesiniz:

[source,specfile]
----
%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org> - 0.1-1
- İlk celaba paketi
- 1.0-1 sürüm - yayın için öylesine bir ikinci madde

----

Yukarıdaki örnekte dikkat etmelisiniz ki, tarih damgası ``*`` karakteriyle başlamalıdır ve haftanın günü, ay, gün ve yıl ve RPM paketçisi hakkındaki iletişim bilgileri formatıyla hazırlanmalıdır. Ardından, Sürüm (Version) - Yayın'dan (Release) önce ``-`` karakterini yerleştirdik, bu alışılagelen bir yaklaşımdır ancak zorunluluk değildir. 

Ve hepsi bu kadar! **celaba** için bütün SPEC dosyasını yazmış bulunmaktayız! Bundan sonraki kısımda bir RPM dosyası nasıl inşa edilir, bunu okuyacaksınız! 

Bütün SPEC dosyası aşağıda aşağıdaki gösterildiği gibi olmalıdır: 

The full SPEC file should now look like the following:

[source,specfile]
----
Name:           celaba
Version:        1.0
Release:        1%{?dist}
Summary:        C ile Yazılmış Bir Merhaba Dünya örneği

License:        GPLv3+
URL:            https://www.example.com/%{name}
Source0:        https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz

Patch0:         celaba-ciktisi-ilk-yama.patch

BuildRequires:  gcc
BuildRequires:  make

%description
C ile yazılmış Merhaba Dünya örneği için 
satırlara sığmayan
epey uzun bir 
tanıtım yazısı

%prep
%setup -q

%patch0

%build
make %{?_smp_mflags}

%install
%make_install


%files
%license LICENSE
%{_bindir}/%{name}


%changelog
* Tue May 31 2016 Adam Miller <maxamillion@gmail.com> - 1.0-1
- İlk celaba paketi

----

``rpmdevtools`` paketi aynı zamanda popüler programlama dilleri için pek çok SPEC dosyası örneği içerir. 

[[rpm-insa-etmek]]
== RPMleri İnşa Etmek

RPMler ``rpmbuild`` komutu aracılığıyla inşa edilirler. Farklı senaryolara ve istenen sonuçlara göre ``rpmbuild`` komutu farklı parametreler gerektirir. Bu kısımda, iki ana senaryoyu ele alacağız:

. kaynak RPM inşa etmek
. ikili RPM inşa etmek

``rpmbuild`` komutu belirli bir dizin ve dosya ypısını gerektirir ki bu yapı ``rpmdev-setuptree`` aracıyla hazırlanmış yapının birebir aynısıdır. Daha önceki talimatlar da aynı şekilde bu gerekli olan yapıya uygundur. 

[[kaynak-rpmler]]
=== Kaynak RPMler

Neden bir kaynak RPM (SRPM) inşa etmeliyiz?

. Yayını yapılmış bir RPM'in İsim-Sürüm-Yayın yapısına özgü gerçek kaynağı korumak için. Kaynak RPMler SPEC dosyasını, kaynak kodunu ve ilşkili yamaları barındırır. Bu tür paketler geri dönüp ne olduğunu incelemek ve hata ayıklamak için kullanışlıdır.

ifdef::community[]
. Çeşitli donanım platformları veya https://tr.wikipedia.org/wiki/Bilgisayar_organizasyonu[işlemci mimarileri] için RPM inşa edebilmek için
endif::community[]
ifdef::rhel[]
. Çeşitli donanım platformları veya işlemci mimarileri için RPM inşa edebilmek için
endif::rhel[]

[[kaynak-rpm-insa-etmek]]
==== Kaynak RPM inşa etmek:

[source,bash]
----
$ rpmbuild -bs _SPECDOSYASİ_

----

_SPECDOSYASİ_ ile SPEC dosyasının konumunu değiştirin. ``-bs`` ise kaynak kodu için kullanılan bir parametredir ve "build source" kelimelerinin kısaltmasından oluşur. 

Şimdi ``belaba``,``pelaba`` ve ``celaba`` için kaynak RPM inşa edeceğiz:

[source,bash]
----
$ cd ~/rpmbuild/SPECS/

$ rpmbuild -bs belaba.spec
Wrote: /home/admiller/rpmbuild/SRPMS/belaba-0.1-1.el7.src.rpm

$ rpmbuild -bs pelaba.spec
Wrote: /home/admiller/rpmbuild/SRPMS/pelaba-0.1.1-1.el7.src.rpm

$ rpmbuild -bs celaba.spec
Wrote: /home/admiller/rpmbuild/SRPMS/celaba-1.0-1.el7.src.rpm

----

İnşa edilecek olan kaynak RPMlerinin (İngilizce: Source RPM, SRPM) ``rpmbuild/SRPM`` dizinine yerleştirileceğine dikkat ediniz ki bu dizin ``rpmbuild`` komutunun gerektirdiği dizinlerden birisidir. 

Bir kaynak RPM derlemek için gerekli olan her şey budur.

[[ikili-rpmler]]
=== İkili RPMler

İkili RPM inşa etmek için iki yöntem vardır:

. Bir kaynak RPM'i ``rpmbuild --rebuild`` komutuyla yeniden derlemek.
. ``rpmbuild -bb`` komutunu kullanarak bir SPEC dosyasından inşa etmek. ``-bb`` parametresi, Türkçesi "ikili inşa" olan "build binary" kelimelerinin kısaltmasıdır. 

[[yeniden-insa]]
==== Kaynak RPM'i Yeniden İnşa Etmek

``belaba``, ``pelaba``, ve ``celaba``'yı yeniden inşa etmek için:

[source,bash]
----
$ rpmbuild --rebuild ~/rpmbuild/SRPMS/belaba-0.1-1.el7.src.rpm
[çıktı törpülendi]

$ rpmbuild --rebuild ~/rpmbuild/SRPMS/pelaba-0.1.1-1.el7.src.rpm
[çıktı törpülendi]

$ rpmbuild --rebuild ~/rpmbuild/SRPMS/celaba-1.0-1.el7.src.rpm
[çıktı törpülendi]

----

Ve RPM paketlerini inşa etmiş bulunmaktasınız. Şimdi, bir kaç detay:

* İkili RPM'in inşasında üretilen çıktı gayet ayrıntılıdır ki bu hata ayıklamak için kullanışlıdır. Çıktı, SPEC dosyasına ve farklı örneklere göre farklılık gösterir. 
* İkili RPMler ``~/rpmbuild/RPMS/MIMARIADI`` isimli bir dosyaya yerleştirilir. ``MIMARIADI``, 
ifdef::community[https://tr.wikipedia.org/wiki/Bilgisayar_organizasyonu[işlemci mimarisine]]
ifdef::rhel[işlemci mimarisine] 
tekabül eder. Eğer paket bir mimariye özgü değilse ``~/rpmbuild/RPMS/noarch`` dizini içerisindedir. 

* ``rpmbuild --rebuild`` komutunu çalıştırınca adım adım şu olaylar gerçekleşir:

+
--
. ``~/rpmbuild`` dizini içerisine SRPM'in içerdiği SPEC dosyasını ve kaynak kodlarını yerleştirir.
. ``~/rpmbuild`` içerisindekiler derlenir. 
. SPEC dosyası da kaynak kodu da temizlenir.
--
+
Eğer SPEC dosyasını ve kaynak kodunu derlemeden sonra da saklamak isterseniz, iki seçeneğiniz var:
+
--
* İnşa sırasında, ``--rebuild`` yerine ``--recompile`` parametresini kullanın.
* Kaynak RPMleri şu komutlarla kurun:
--
+
[source,bash]
----
$ rpm -Uvh ~/rpmbuild/SRPMS/belaba-0.1-1.el7.src.rpm
Updating / installing...
   1:belaba-0.1-1.el7                  ################################# [100%]

$ rpm -Uvh ~/rpmbuild/SRPMS/pelaba-0.1.1-1.el7.src.rpm
Updating / installing...
   1:pelaba-0.1.1-1.el7                ################################# [100%]

$ rpm -Uvh ~/rpmbuild/SRPMS/celaba-1.0-1.el7.src.rpm
Updating / installing...
   1:celaba-1.0-1.el7                  ################################# [100%]

----
+
SPEC dosyasını ve kaynak kodlarıyla etkileşimi sürdürmek için, gördüğünüz gibi, ``rpm -Uvh`` komutunu kullanmanız gerekmektedir.

[[ikili-insa]]
==== İkili Paketi SPEC dosyasından inşa etmek

``belaba``, ``pelaba`` ve ``celaba``yı SPEC dosyalarından inşa edebilmek için, şu komutları çalıştırın:

[source,bash]
----
$ rpmbuild -bb ~/rpmbuild/SPECS/belaba.spec

$ rpmbuild -bb ~/rpmbuild/SPECS/pelaba.spec

$ rpmbuild -bb ~/rpmbuild/SPECS/celaba.spec

----

Hepsi bu kadar! SPEC dosyalarından RPMleri inşa etmiş bulunmaktasınız. 

xref:yeniden-insa[] kısmındaki bilgilerin çoğunluğu burada da geçerlidir. 

[[checking-rpms-for-sanity]]
== RPMlerin Geçerliliğini Denetleme

Bir paketi oluşturduktan sonra paket kalitesini test etmek hiç de fena bir fikir değildir. Paketin kalitesinden kasıt, paketin sunduğu yazılım değil paketin kendi kalitesidir. Bu denetimi yapmak üzere kullanılan ana araç https://github.com/rpm-software-management/rpmlint[rpmlint]'dır. Bu araç sayesinde RPM'in bakım kolaylaşır, paketin geçerlilik denetimi ve paketin statik hata analizi iyileşir. 

``rpmlint``'in oldukça sıkı ilkelere sahip olduğa dikkat ediniz. Sonraki örneklerde göreceğiniz gibi, kimi zaman hata ve uyarı mesajlarını es geçmekte kimi zaman sıkıntı yoktur.

NOTE: Göreceğiniz örneklerde ``rpmlint`` bize gayet sade bir çıktı sunmakta. Eğer hataların ve uyarıların detaylı bir çıktısını istiyorsanız, bu komut yerine ``rpmlint -i`` komutunu kullanabilirsiniz. 


[[belaba-spec-dosyasini-denetlemek]]
=== Belaba SPEC dosyasını Denetlemek

``belaba`` için ``rpmlint`` çıktısı şöyledir:

[source,bash]
----
$ rpmlint belaba.spec
belaba.spec: W: invalid-url Source0: https://www.example.com/belaba/releases/belaba-0.1.tar.gz HTTP Error 404: Not Found
0 packages and 1 specfiles checked; 0 errors, 1 warnings.

----

Gözlemlenenler:

* ``belaba.spec`` için elimizde tek bir uyarı var ki bu da ``Source0`` yönergesindeki bağlantıya ulaşamadığından bahsediyor. Bu anlaşılmayacak bir şey değil, çünkü ``example.com`` adresinde belirttiğimiz dosya yok. Yine de belki gelecekte bağlantının geçerli olabileceğini varsayarak, bu uyarıyı görmezden gelebiliriz. 

Bu da ``belaba`` kaynak RPM paketi için ``rpmlint`` çıktısı:

[source,bash]
----
$ rpmlint ~/rpmbuild/SRPMS/belaba-0.1-1.el7.src.rpm
belaba.src: W: invalid-url URL: https://www.example.com/belaba HTTP Error 404: Not Found
belaba.src: W: invalid-url Source0: https://www.example.com/belaba/releases/belaba-0.1.tar.gz HTTP Error 404: Not Found
1 packages and 0 specfiles checked; 0 errors, 2 warnings.

----

Gözlemlenenler: 

* ``Belaba`` kaynak RPM paketi için fazladan bir uyarımız daha var. Bu uyarı, ``URL`` yönergesindeki bağlantının ulaşılamaz olmasıyla ilgili. Gelecekte bu bağlantının geçerli olacağını varsayarak, bu uyarıyı da gözardı edebiliriz.  


[[ikili-belaba-rpm-denetimi]]
=== Belaba'nın İkili RPM'ini Denetleme

İkili RPMleri denetlerken, ``rpmlint`` şu detayları da incelemekte:

. Belgelendirme
ifdef::community[. https://tr.wikipedia.org/wiki/Man_(elkitabı)_sayfası[Man (elkitabı) sayfaları]]
ifdef::rhel[. Man (elkitabı) sayfaları]
. Dosya Sistemi Hiyerarşisi Standartı'nın doğru kullanımı


``belaba`` ikili dosyası için ``rpmlint`` çıktısı şu şekildedir:

[source,bash]
----
$ rpmlint ~/rpmbuild/RPMS/noarch/belaba-0.1-1.el7.noarch.rpm
belaba.noarch: W: invalid-url URL: https://www.example.com/belaba HTTP Error 404: Not Found
belaba.noarch: W: no-documentation
belaba.noarch: W: no-manual-page-for-binary belaba
1 packages and 0 specfiles checked; 0 errors, 3 warnings.

----

Gözlemlenenler: 

* ``no-documentation`` (Tr. belgelendirme yok) ve ``no-manual-page-for-binary`` (Tr. ikili (paket) için man sayfası yok) uyarıları RPM paketimizin belgeleri olmadığını gösteriyor, çünkü böyle bir şey sağlamadık. 

Uyarıları görmezden gelirsek, RPM paketimiz ``rpmlint`` denetiminden geçmiş sayılır.

[[pelaba-spec-dosyasini-denetlemek]]
=== Pelaba SPEC Dosyasını Denetlemek

``Pelaba``'nın SPEC dosyası için ``rpmlint`` çıktısı şöyledir:


[source,bash]
----
$ rpmlint pelaba.spec
pelaba.spec:30: E: hardcoded-library-path in %{buildroot}/usr/lib/%{name}
pelaba.spec:34: E: hardcoded-library-path in /usr/lib/%{name}/%{name}.pyc
pelaba.spec:39: E: hardcoded-library-path in %{buildroot}/usr/lib/%{name}/
pelaba.spec:43: E: hardcoded-library-path in /usr/lib/%{name}/
pelaba.spec:45: E: hardcoded-library-path in /usr/lib/%{name}/%{name}.py*
pelaba.spec: W: invalid-url Source0: https://www.example.com/pelaba/releases/pelaba-0.1.1.tar.gz HTTP Error 404: Not Found
0 packages and 1 specfiles checked; 5 errors, 1 warnings.

----

Gözlemlenenler: 

* ``invalid-url Source0`` (Tr. Source0 için geçerli adres) uyarısı Source0'da belirtilen adresin geçersiz olduğuna işaret etmekte. Bu beklenen bir durum, çünkü ``example.com`` adresindeki dosya yok. Gelecekte bu adresin çalışacağını varsayarak bu uyarıyı görmezden gelebiliriz. 
* Pek çok hata var, çünkü kasıtlı olarak SPEC dosyasını gerekenden daha basit yazdık ve ``rpmlint`` bunu raporluyor. 
* ``hardcoded-library-path`` (Tr. elle belirtilmiş konum) hatası, elle kütüphane konumu yerine ``%{_libdir}`` kullanmamızı öneriyor. Şimdilik bu örnek için bu hatayı görmezden gelebiliriz, ancak gelecekte hazırlayacağınız paketlerde bu hatayı görmezden gelmek için iyi bir nedene ihtiyacınız var. 

``Pelaba``'nın kaynak RPM'inin ``rpmlint`` çıktısı şu şekildedir:

[source,bash]
----
$ rpmlint ~/rpmbuild/SRPMS/pelaba-0.1.1-1.el7.src.rpm
pelaba.src: W: invalid-url URL: https://www.example.com/pelaba HTTP Error 404: Not Found
pelaba.src:30: E: hardcoded-library-path in %{buildroot}/usr/lib/%{name}
pelaba.src:34: E: hardcoded-library-path in /usr/lib/%{name}/%{name}.pyc
pelaba.src:39: E: hardcoded-library-path in %{buildroot}/usr/lib/%{name}/
pelaba.src:43: E: hardcoded-library-path in /usr/lib/%{name}/
pelaba.src:45: E: hardcoded-library-path in /usr/lib/%{name}/%{name}.py*
pelaba.src: W: invalid-url Source0: https://www.example.com/pelaba/releases/pelaba-0.1.1.tar.gz HTTP Error 404: Not Found
1 packages and 0 specfiles checked; 5 errors, 2 warnings.

----

Gözlemlenenler:

* Şimdi gördüğümüz ``invalid-url URL`` (Tr. geçersiz adres) hatası henüz ulaşılamayan ``URL`` yönergesiyle ilgilidir. Gelecekte bu adresin kullanılabilir olacağını düşünerek bu hatayı görmezden gelebiliriz. 

[[pelaba-ikili-rpm-denetlemek]]
=== İkili Pelaba RPM'ini Denetlemek


İkili RPMleri denetlerken, ``rpmlint`` şu detayları da incelemektedir:

. Belgelendirme
ifdef::community[. https://tr.wikipedia.org/wiki/Man_(elkitabı)_sayfası[Man (elkitabı) sayfaları]]
ifdef::rhel[. Man (elkitabı) sayfaları]
. Dosya Sistemi Hiyerarşisi Standartı'nın doğru kullanımı

``Pelaba``'nın ikili RPM'inin ``rpmlint`` çıktısı şu şekildedir:

[source,bash]
----
$ rpmlint ~/rpmbuild/RPMS/noarch/pelaba-0.1.1-1.el7.noarch.rpm
pelaba.noarch: W: invalid-url URL: https://www.example.com/pelaba HTTP Error 404: Not Found
pelaba.noarch: W: only-non-binary-in-usr-lib
pelaba.noarch: W: no-documentation
pelaba.noarch: E: non-executable-script /usr/lib/pelaba/pelaba.py 0644L /usr/bin/env
pelaba.noarch: W: no-manual-page-for-binary pelaba
1 packages and 0 specfiles checked; 1 errors, 4 warnings.

----

Gözlemlenenler

* ``no-documentation`` (Tr. belgelendirme yok) ve ``no-manual-page-for-binary`` (Tr. ikili (paket) için man sayfası yok) uyarıları RPM paketimizin belgeleri olmadığını gösteriyor, çünkü böyle bir şey sağlamadık. 
* ``only-non-binary-in-usr-lib`` uyarısı, ``/usr/lib`` dizini içerisinde ikili olmayan yapıları eklediğimizi belirtiyor. Bu dizin, ikili dosya olması gereken paylaşımlı nesne dosyaları içindir. Bundan dolayı, ``rpmlint``, ``/usr/lib`` içerisine ekleyeceğimiz bir veya birden fazla dosyanın ikili olmasını bekler.
+
Bu örnek, ``rpmlint``in nasıl 
ifdef::community[https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard[Dosya hiyerarşisi standartını]]
ifdef::rhel[Dosya hiyerarşisi standartını]
koruduğunu gösterir. 
.
+
Genellikle RPM makroları aracılığıyla dosyaları doğru konumlarına yerleştiririz. Yalnızca bu örnek için, bu uyarıyı görmezden geliyoruz. 
* ``non-executable-script`` (Tr. Çalıştırılamayan betik) hatası ``/usr/lib/pelaba/pelaba.py`` dosyasının çalıştırma yetkileri olmadığını belirtiyor. Bu dosya, bir 
ifdef::community[https://en.wikipedia.org/wiki/Shebang_%28Unix%29[mevzu]]
ifdef::rhel[mevzu (shebang)]
içerdiğinden dolayı ``rpmlint`` dosyanın çalıştırılabilir olmasını bekliyor. Şimdilik, bu dosyaya çalıştırma yetkileri vermiyoruz ve hatayı görmezden geliyoruz. 
, ``rpmlint`` expects

Yukarıdaki hatalar ve uyarıları görmezsek, RPM'imiz ``rpmlint`` denetimini geçti sayılır. 


[[celaba-spec-denetlemek]]
=== Celaba'nın SPEC Dosyasını Denetleme

``Celaba``'nın SPEC dosyası için ``rpmlint`` çıktısı şöyledir:

[source,bash]
----
$ rpmlint ~/rpmbuild/SPECS/celaba.spec
/home/admiller/rpmbuild/SPECS/celaba.spec: W: invalid-url Source0: https://www.example.com/celaba/releases/celaba-1.0.tar.gz HTTP Error 404: Not Found
0 packages and 1 specfiles checked; 0 errors, 1 warnings.

----

Gözlemlenenler:

* ``celaba.spec`` için elimizde tek bir uyarı var ki bu da ``Source0`` yönergesindeki bağlantıya ulaşamadığından bahsediyor. Bu anlaşılmayacak bir şey değil, çünkü ``example.com`` adresinde belirttiğimiz dosya yok. Yine de belki gelecekte bağlantının geçerli olabileceğini varsayarak, bu uyarıyı görmezden gelebiliriz. 

``Celaba``'nın kaynak RPM'inin ``rpmlint`` çıktısı şu şekildedir:

[source,bash]
----
$ rpmlint ~/rpmbuild/SRPMS/celaba-1.0-1.el7.src.rpm
celaba.src: W: invalid-url URL: https://www.example.com/celaba HTTP Error 404: Not Found
celaba.src: W: invalid-url Source0: https://www.example.com/celaba/releases/celaba-1.0.tar.gz HTTP Error 404: Not Found
1 packages and 0 specfiles checked; 0 errors, 2 warnings.

----

Gözlemlenenler:

* Şimdi gördüğümüz ``invalid-url URL`` (Tr. geçersiz adres) hatası henüz ulaşılamayan ``URL`` yönergesiyle ilgilidir. Gelecekte bu adresin kullanılabilir olacağını düşünerek bu hatayı görmezden gelebiliriz.

[[celaba-ikili-rpm-denetlemek]]
=== Celaba İkili RPM'inin 

İkili RPMleri denetlerken, ``rpmlint`` şu detayları da incelemektedir:

. Belgelendirme
ifdef::community[. https://tr.wikipedia.org/wiki/Man_(elkitabı)_sayfası[Man (elkitabı) sayfaları]]
ifdef::rhel[. Man (elkitabı) sayfaları]
. Dosya Sistemi Hiyerarşisi Standartı'nın doğru kullanımı
.

``Celaba``'nın ikili RPM'inin ``rpmlint`` çıktısı şu şekildedir:

[source,bash]
----
$ rpmlint ~/rpmbuild/RPMS/x86_64/celaba-1.0-1.el7.x86_64.rpm
celaba.x86_64: W: invalid-url URL: https://www.example.com/celaba HTTP Error 404: Not Found
celaba.x86_64: W: no-documentation
celaba.x86_64: W: no-manual-page-for-binary celaba
1 packages and 0 specfiles checked; 0 errors, 3 warnings.
----

Gözlemlenenler

* ``no-documentation`` (Tr. belgelendirme yok) ve ``no-manual-page-for-binary`` (Tr. ikili (paket) için man sayfası yok) uyarıları RPM paketimizin belgeleri olmadığını gösteriyor, çünkü böyle bir şey sağlamadık. 

Uyarıları görmezden gelirsek, RPM paketimiz ``rpmlint`` denetiminden geçmiş sayılır.

Ve RPMlerimiz hazır olduğu gibi ``rpmlint`` testinden de geçti. Bu kısım yalnızca nasıl RPM paketleneceğini anlatan bir rehberdi, daha fazla bilgi için xref:ileri-duzey-konular[] kısmına göz atabilirsiniz.
